<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法题库系列丨目录索引]]></title>
    <url>%2Fposts%2Falgorithm%2Findex%2F</url>
    <content type="text"><![CDATA[介绍 文章目录 Linear List Array Remove Duplicates from Sorted Array Remove Duplicates from Sorted Array II Longest Consecutive Sequence Two Sum 3Sum 3Sum Closest 4Sum Remove Element Move Zeroes Next Permutation Permutation Sequence Valid Sudoku Trapping Rain Water Rotate Image Plus One Climbing Stairs Set Matrix Zeroes Gas Station Candy Majority Element Rotate Array Contains Duplicate Contains Duplicate II Contains Duplicate III Product of Array Except Self Game of Life Increasing Triplet Subsequence Single Linked List Reverse Linked List Odd Even Linked List Add Two Numbers Reverse Linked List II Partition List Remove Duplicates from Sorted List Remove Duplicates from Sorted List II Rotate List Remove Nth Node From End of List Swap Nodes in Pairs Reverse Nodes in k-Group Copy List with Random Pointer Linked List Cycle Linked List Cycle II Reorder List LRU Cache Palindrome Linked List String Valid Palindrome Implement strStr() String to Integer (atoi) Add Binary Longest Palindromic Substring Regular Expression Matching Wildcard Matching Longest Common Prefix Valid Number Integer to Roman Roman to Integer Count and Say Anagrams Valid Anagram Simplify Path Length of Last Word Isomorphic Strings Word Pattern Stack &amp; Queue Stack Min Stack Valid Parentheses Longest Valid Parentheses Largest Rectangle in Histogram Evaluate Reverse Polish Notation Implement Stack using Queues Queue Implement Queue using Stacks Binary Tree Binary Tree Traversal Binary Tree Preorder Traversal Binary Tree Inorder Traversal Binary Tree Postorder Traversal Binary Tree Level Order Traversal Binary Tree Level Order Traversal II Binary Tree Right Side View Invert Binary Tree Binary Search Tree Iterator Binary Tree Zigzag Level Order Traversal Recover Binary Search Tree Same Tree Symmetric Tree Balanced Binary Tree Flatten Binary Tree to Linked List Populating Next Right Pointers in Each Node II Construct Binary Tree Construct Binary Tree from Preorder and Inorder Traversal Construct Binary Tree from Inorder and Postorder Traversal Binary Search Trees Unique Binary Search Trees Unique Binary Search Trees II Validate Binary Search Tree Convert Sorted Array to Binary Search Tree Convert Sorted List to Binary Search Tree LCA of BST Kth Smallest Element in a BST Recursive of Binary Tree Minimum Depth of Binary Tree Maximum Depth of Binary Tree Path Sum Path Sum II Binary Tree Maximum Path Sum Populating Next Right Pointers in Each Node Sum Root to Leaf Numbers LCA of Binary Tree Segment Tree Range Sum Query - Mutable Sort Insertion Sort Insertion Sort List Merge Sort Merge Two Sorted Arrays Merge Two Sorted Lists Merge k Sorted Lists Sort List Quick Sort Sort Colors Kth Largest Element in an Array Bucket Sort First Missing Positive Count Sort H-Index Radix Sort Maximum Gap Other Sort Largest Number Search Search for a Range Search Insert Position Search in Rotated Sorted Array Search in Rotated Sorted Array II Search a 2D Matrix Search a 2D Matrix II Find Minimum in Rotated Sorted Array Find Minimum in Rotated Sorted Array II Median of Two Sorted Arrays H-Index II Violence Enumeration Subsets Subsets II Permutations Permutations II Combinations Letter Combinations of a Phone Number Breadth-First Search Word Ladder Word Ladder II Surrounded Regions Depth-First Search Additive Number Palindrome Partitioning Unique Paths Unique Paths II N-Queens N-Queens II Restore IP Addresses Combination Sum Combination Sum II Combination Sum III Generate Parentheses Sudoku Solver Word Search 相关资料 LeetCode 算法珠玑 代码实现(C#版)]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程技巧</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题库丨Longest Consecutive Sequence]]></title>
    <url>%2Fposts%2Falgorithm%2FLongest%20Consecutive%20Sequence%2F</url>
    <content type="text"><![CDATA[描述 Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity. 示例 12Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. 算法分析难度：高分析：给定未排序的整型数组，找到数值连续的元素，并返回连续元素的最大长度。思路：首先考虑一般的思路，可以将数组先排序，然后遍历数组元素，判断是否连续，返回最大连续元素的个数，这样的话，循环的复杂度为O (n)，排序的复杂度为O (nlgn)，算法的整体复杂度为O (nlgn)，并不满足题目要求的复杂度。所以，该算法题目的难点是如何采用O (n)的算法。再考虑使用哈希表来存储元素，因为哈希表提供了O (1)复杂度的Contains方法，以便我们快速的访问元素:&emsp;1. 首先，我们将数组元素构造成哈希表，并定义变量longestStreak=0，用来记录最大连续元素的个数;&emsp;2. 遍历哈希表,判断当前元素num-1，是否存在在哈希表中：&emsp;&emsp;a). 如果不存在，不用处理，继续遍历哈希表下一个元素;&emsp;&emsp;b). 如果存在，说明有比当前元素小1的值，则定义currentNum=当前元素，定义currentStreak=1，表示currentNum作为开始比较的元素，刚开始的连续元素个数为1；&emsp;&emsp;c). 开始后续比较，如果哈希表存在currentNum+1的元素，表示当前元素currentNum有后续相邻的元素，连续的元素为之前最大连续元素次数+1，开始下个一个元素比较，即currentNum+1;&emsp;&emsp;d). 后续比较结束后，将本次循环获得的currentStreak作为本次循环记录的最大连续元素个数，记录本次最大连续次数currentStreak和之前最大连续次数longestStreak的最大值到longestStreak，并进入下一个循环遍历;&emsp;3. 循环遍历结束后，返回最大连续次数longestStreak; 代码实例(C#)12345678910111213141516171819202122public int LongestConsecutive(int[] nums)&#123; var numSet = new HashSet&lt;int&gt;(nums); int longestStreak = 0; foreach (int num in numSet) &#123; if (!numSet.Contains(num - 1)) &#123; int currentNum = num; int currentStreak = 1; while (numSet.Contains(currentNum + 1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = Math.Max(longestStreak, currentStreak); &#125; &#125; return longestStreak;&#125; 复杂度 时间复杂度：O (n). 空间复杂度：O (n).]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程技巧</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题库丨RemoveDuplicates II]]></title>
    <url>%2Fposts%2Falgorithm%2FRemoveDuplicates%20II%2F</url>
    <content type="text"><![CDATA[描述 Follow up for “Remove Duplicates“:What if duplicates are allowed at most twice? 示例 1234Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. 算法分析难度：中分析：条件参考Remove Duplicates，只不过之前元素只允许重复1次，现在改为最多可以重复2次。思路：输入的数组任然排好序的，我们定义i,从i=0开始，依次遍历数组中的每个元素：当i&lt;2时，不管怎样，元素都会满足条件，也就是说，前2条数据总是满足最多重复2次;当i&gt;2时，比较遍历当前元素数组[i]是否满足大于元素数组[i-2]：&emsp;1. 如果不满足，i值不变，遍历下个元素;&emsp;2. 如果满足，把数组[i-2]值赋值给数组[i],数组0-i的元素都为有效值,i自加1;再次循环判断，一直到数组最后一个元素. 代码实例(C#)12345678910public static int RemoveDuplicates2(int[] nums)&#123; int i = 0; foreach (var num in nums) &#123; if (i &lt; 2 || num &gt; nums[i - 2]) nums[i++] = num; &#125; return i;&#125; 复杂度 时间复杂度：O (n). 空间复杂度：O (1). 相关算法 Remove Duplicates]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程技巧</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题库丨RemoveDuplicates]]></title>
    <url>%2Fposts%2Falgorithm%2FRemoveDuplicates%2F</url>
    <content type="text"><![CDATA[描述 Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. 示例 12345Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the new length. 算法分析难度：低分析：要求给定的排序后的数组，将其中重复的元素去除（是的每个元素只出现一次），并返回最终数组的长度。算法不要分配额外的数组空间。思路：既然输入的数组已然排好序，我们可以定义i,j两个数组下标值，开始i初始为0，j从1开始，遍历数组：如果数组[j]==数组[i],表示有重复，重复元素个数i不用累计，遍历数组下一条;如果数组[j]！=数组[i]，表示没有重复，把数组[i]值用数组[j]替代，这样数组0-i为新的数组，且不重复,i自增+1，比较下一个元素;依次遍历，直到数组[j]至最后一个元素。 代码实例(C#)1234567891011121314public static int RemoveDuplicates(int[] nums)&#123; if (nums.Length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.Length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125; 复杂度 时间复杂度：O (n). i,j最多遍历n次 空间复杂度：O (1). 相关算法 RemoveDuplicates II]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程技巧</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
